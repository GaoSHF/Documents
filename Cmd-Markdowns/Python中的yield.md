# Python中的yield
---

    mylist = [x*x for x in range(3)]
    print mylist
    mygen=(x*x for x in range(3))
    print mygen

代码解释：
行1生成一个列表list，这个列表的每个元素由x的平方组成，x的取值为range(3)，也就是0,1,2。因此这个列表有三个元素：0的平方(0)，1的平方(1)，2的平方(4)。
行2打印出这个列表的内容，显示结果果真是[0,1,4]
行3生成的是一个生成器generator，它和行1唯一的不同就是它用的小括号。但是产生的返回值并不再是一个列表了。那是什么呢?
行4想要打印出来这个mygen生成器，但结果显示是这样的: <generator object <genexpr> at 0x022F8030> 一个内存地址。
如上例子所示，其实这个mygen生成器就是用来生成x的平方的东西。这个结果呢就存在上面显示的内存地址里。但是由于你还没说你到底要谁的平方，所以只能看到个地址不能看到答案。mylist则不同，它是把所有答案穷举列在内存里了，你需要哪个就从里面找出来即可，比较耗费资源。而mygen则还没生成，你需要哪个我现制造一个出来放在一个内存空间显示，节省了资源。

生成器怎么用：

    mygen=(x*x for x in range(3))
    for i in mygen:
        print (i)

这样就可以八mygen生成的所有平方书拿出来得到结果：
0       1       4
注意，答案是一个一个蹦出来的，就好像循环读取一样。辣么，当你需要循环读取、而不是一下子全显示出来的时候，用生成器是最好不过的了。

---"在python中，当你定义一个函数，使用了yield关键字时，这个函数就是一个生成器" (也就是说，只要有yield这个词出现，你在用def定义函数的时候，系统默认这就不是一个函数啦，是一个生成器)
--- 一般def定义的函数，都会return一个返回值。而def定义的生成器，返回的则是一个对象，也就是上面提到的类似于“内存地址”的东西。
--- 如果需要生成器返回（下一个）值，需要调用.next()函数。其实当系统判断def是生成器时，就会自动支持.next()函数

    def fib(max):
    a, b = 1, 1
    while a < max:
        yield a
        a, b = b, a+b

    for n in fib(15):
        print n
        
    m = fib(13)
    print m
    print m.next()
    print m.next()
    print m.next()

以上是一段关于斐波那契数列的程序。
fib()函数因为含有yield，被系统默认为是一个生成器。

for语句调用了fib(15)。当max=15时，进入fib()生成器，执行到yield a， 返回a值以及整个生成器暂停的状态，将a值赋给n， 打印出来；因为是for语句循环，所以又回到fib(15)语句，由于是生成器，因此从上次截断的位置开始执行，b值赋给a, a+b值赋给b，又因为是while语句，则继续while循环，yield a值，循环暂停跳出返回a值及生成器状态，把a值赋给n, 打印n。如此往复，一直循环到15结束。

m被赋了fib(13)这个生成器，每一次执行m.next()函数就会打印下一个值。

从上面的分析过程，我们看一下运行结果：
![](/home/gao/Pictures/yield.png)
1. 每个生成器只能使用一次。比如上个例子中的m生成器，一旦打印完m的6个值，就没有办法再打印m的值了，因为已经吐完了。
2. yield一般都在def生成器定义中搭配一些循环语句使用，比如for或者while，以防止运行到生成器末尾跳出生成器函数，就不能再yield了。有时候，为了保证生成器函数永远也不会执行到函数末尾，会用while True: 语句，这样就会保证只要使用next()，这个生成器就会生成一个值，是处理无穷序列的常见方法。


--------------------- 
原文：https://blog.csdn.net/u012671171/article/details/42169843 

